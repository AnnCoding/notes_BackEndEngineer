七天八股文速记
====

---

* 接口和抽象类的区别


```
（1）继承关系：

抽象类可以有构造函数，并且可以有字段（成员变量），也可以包含已经实现的方法。
接口不能包含构造函数，字段，或已经实现的方法。接口只能包含抽象方法（没有方法体）和常量。

（2）多继承：

Java中，类只能单继承，一个类只能有一个直接父类（除非它们实现接口）。
一个类可以实现多个接口。这使得接口在实现多重继承时非常有用，因为类可以实现多个不同的接口。

（3）构造函数：

抽象类可以有构造函数，这些构造函数在子类中被调用。
接口不能有构造函数，因为接口不能被实例化。

（4）方法实现：

抽象类可以包含已经实现的方法，子类可以选择性地重写这些方法。
接口只能包含抽象方法，子类必须提供这些方法的具体实现。

（5）关系类型：

抽象类通常表示"is-a"关系，即子类是父类的特定类型。
接口通常表示"can-do"关系，即类可以做某些事情。

（6）用途：

抽象类通常用于创建类层次结构，并提供一些通用的实现，而留下一些方法供子类实现或重写。
接口用于定义一组规范，以确保实现了该接口的类具有某些行为。接口常用于实现多态和解耦合。

（7）字段（成员变量）：

抽象类可以包含字段，可以是实例变量或静态变量。
接口只能包含常量，这意味着接口中的字段是隐式地 public、static 和 final 的，无法修改其值。

（8）继承规则：

一个类只能继承一个抽象类，但可以实现多个接口。这意味着子类可以继承抽象类的行为并实现多个接口的规范。

（9）默认方法：

在Java 8及以后的版本，接口可以包含默认方法（默认方法有方法体），以允许向已经存在的接口添加新方法而不破坏实现该接口的现有类。
抽象类不能包含默认方法。

（10）访问修饰符：

抽象类的方法可以包含不同的访问修饰符，例如 public、protected、private 等。
接口的方法默认是 public 的，且不能使用其他修饰符。

```

* java中的继承和c++有什么不同
```
(1) 单继承 vs. 多继承：

Java 支持单继承，这意味着一个类只能继承自一个父类。这是为了防止多继承可能导致的复杂性和歧义问题。
C++ 支持多继承，允许一个类继承自多个父类。这为C++提供了更大的灵活性，但也可能导致菱形继承等问题。

(2) 虚函数和方法重写：

在C++中，您需要使用关键字 virtual 来标记基类的虚函数，并在派生类中使用 override 来表示方法重写。
在Java中，所有非 final 方法都被默认视为虚函数，可以在子类中直接重写，不需要显式的关键字。此外，Java还引入了 @Override 注解来明确指示方法重写。

(3) 多态性：

Java 中的多态性更为简单和明确，因为所有非 final 方法都是虚函数，可以在运行时动态绑定。
C++ 中的多态性需要显式地使用 virtual 关键字，并要注意类继承体系中虚函数表的构建。

(4) 析构函数和垃圾回收：

C++ 允许程序员手动管理内存，包括使用析构函数来释放资源。
Java 使用垃圾回收器自动管理内存，没有显式析构函数，而是依赖于垃圾回收来释放不再使用的对象。

(5) 对象生命周期：

C++ 中的对象可以具有栈生命周期（自动存储期）或堆生命周期（动态分配）。堆上分配的对象需要手动释放。
Java 中的对象都具有堆生命周期，Java虚拟机负责管理对象的分配和回收。

(6) 指针 vs. 引用：

C++ 使用指针来引用对象，允许指针的重新赋值和指针运算。
Java 使用引用，但不允许重写引用对象，因此更容易进行内存管理。

(7)访问控制：

在C++中，类的成员可以有 public、private 和 protected 访问控制，允许更细粒度的控制成员的可见性。
Java 使用更简单的 public、private 和 protected 访问控制，没有C++中的 friend 关键字。

```

* java中有哪些数据结构?用过Hashmap吗， 说一下hashMap底层实现
```
数组 (Array): 数组是具有固定大小的线性数据结构，可以存储相同数据类型的元素。

列表 (List): Java提供了许多列表实现，包括ArrayList、LinkedList和Vector。列表允许按顺序存储元素，可以包含重复元素。

集合 (Set): 集合是一种不允许重复元素的数据结构。Java提供了HashSet、LinkedHashSet和TreeSet等集合类。

映射 (Map): 映射用于存储键值对，其中每个键关联一个值。常见的映射实现包括HashMap、LinkedHashMap和TreeMap。

栈 (Stack): 栈是一种后进先出（LIFO）的数据结构，通常用于跟踪方法调用和解析表达式。

队列 (Queue): 队列是一种先进先出（FIFO）的数据结构，用于实现任务调度和处理多线程问题。Java中有Queue接口，以及实现了它的类如PriorityQueue、LinkedList等。

堆 (Heap): 堆是一种特殊的树形数据结构，通常用于实现优先级队列。Java的PriorityQueue类是堆的实现。

树 (Tree): Java提供了许多树结构的实现，如二叉树、AVL树和红黑树。这些数据结构通常用于实现高效的查找和排序操作。

图 (Graph): 尽管Java标准库没有直接提供图数据结构，但可以通过自定义类来实现图的表示。

链表 (LinkedList): 链表是一种基本的数据结构，Java中的LinkedList类实现了双向链表。

栈 (Stack) 和队列 (Queue)： Java还提供了Stack类和Queue接口，用于实现栈和队列数据结构。

这只是Java中一些常见的数据结构，还有其他数据结构和集合，如BitSet、HashTable等。

```

>hashmap 的原理：<br>
>> * 数组桶（Buckets）： HashMap内部维护一个数组，这个数组被称为桶。桶的数量通常是一个质数，这有助于减少碰撞（即多个键映射到相同的桶）的可能性。<br>
>> * 哈希函数： 当您向HashMap中插入一个键值对时，HashMap会使用哈希函数来计算键的哈希码。哈希码是一个整数，表示键在桶数组中的位置。<br>
>> * 索引计算： 根据哈希码，HashMap计算桶数组的索引。通常，这是通过取哈希码的模来实现的，即hash % bucketCount，其中bucketCount是桶的数量。<br>
>> * 桶中链表或红黑树： 如果发生碰撞，即多个键具有相同的哈希码并分配到同一个桶中，HashMap使用一个链表或红黑树来存储这些键值对。在Java 8及以后的版本中，当一个桶中的键值对数量超过一定阈值时，它会被转化为红黑树，以确保更快的查找性能。<br>
>> * 扩容： 当桶中的元素数量达到一定的阈值（称为负载因子），HashMap会触发扩容操作。扩容涉及创建一个新的更大的桶数组，然后将所有现有的键值对重新分配到新的桶数组中，以保持哈希表的性能。<br>
>> * 初始化容量和负载因子： 您可以在创建HashMap时指定初始容量和负载因子。初始容量是桶数组的大小，负载因子是触发扩容的元素数量与桶数组大小之比。适当选择这些参数可以影响HashMap的性能。<br>

* java中用的是指传递还是引用传递

```
在Java中，参数传递是按值传递（pass by value）。
这意味着当你将一个变量传递给方法作为参数时，实际上是将该变量的副本传递给方法，而不是原始变量本身。
方法对参数进行操作时，只会影响参数的副本，不会影响原始变量。

这可能会与引用传递（pass by reference）有些混淆，但在Java中并没有真正的引用传递。
当你传递一个对象作为参数时，你传递的是对象引用的副本，这个副本指向了相同的对象。
虽然你可以通过这个引用来修改对象的内部状态，但你无法通过这个引用来改变对象本身。
```


* 面向过程和面向对象有什么区别
```
面向过程编程（Procedural Programming）和面向对象编程（Object-Oriented Programming）是两种不同的编程范例，它们有一些关键区别：

基本思想：
面向过程： 面向过程编程以过程和函数为中心，程序由一系列函数调用组成。开发者关注解决问题所需的具体步骤和操作。
面向对象： 面向对象编程以对象为中心，将数据和方法封装在对象内部，通过对象之间的交互来解决问题。开发者关注对象之间的协作和交互。

组织代码：
面向过程： 代码以线性的方式组织，侧重于分解问题为一系列步骤，通常使用函数和过程。
面向对象： 代码以对象的方式组织，强调数据和行为的封装，通常使用类和对象。

重用性：
面向过程： 重用性相对较低，因为函数通常是特定问题的解决方案，不太容易在不同上下文中重复使用。
面向对象： 重用性相对较高，因为对象可以被多次使用，而且可以通过继承和多态等机制进行扩展和定制。

维护性：
面向过程： 维护性可能较差，因为代码通常分散在多个函数中，难以理解和修改。
面向对象： 维护性通常较好，因为代码被组织为对象，每个对象负责自己的一部分功能，易于理解和维护。

抽象性：
面向过程： 相对较低的抽象性，侧重于具体实现。
面向对象： 相对较高的抽象性，侧重于问题的抽象建模。

多态性：
面向过程： 较少支持多态性。
面向对象： 支持多态性，可以通过继承和接口实现。

封装性：
面向过程： 通常较弱的封装性。
面向对象： 有更强的封装性，对象的内部状态和行为可以被控制和隐藏。

继承性：
面向过程： 通常不支持继承。
面向对象： 支持继承，可以实现代码重用和扩展。

```

* final、finally、finalize 的区别？
```

final、finally 和 finalize 是 Java 中的三个不同概念，它们有完全不同的用途和含义。

final:
final 是一个关键字，可以用于修饰类、方法、变量等。
用于修饰类：表示该类不能被继承，即为最终类。
用于修饰方法：表示方法不能被子类重写。
用于修饰变量：表示变量为常量，其值不能被修改。

finally:
finally 是一个关键字，用于异常处理中的 try-catch-finally 结构。
无论是否发生异常，finally 代码块中的语句都会被执行。
常用于确保资源的释放，如关闭文件、数据库连接等。

finalize:
finalize 是一个方法，用于对象的垃圾回收。
当对象被垃圾回收器回收时，会调用该对象的 finalize 方法（如果该方法被覆盖）。
该方法用于执行对象资源的释放和清理操作。

总结：
final 是一个关键字，用于修饰类、方法和变量，表示不可改变、不可继承或不可重写。
finally 是一个关键字，用于异常处理，确保无论是否发生异常都会执行的代码块。
finalize 是一个方法，用于对象的垃圾回收，在对象被销毁前执行清理操作。不建议过多使用该方法，因为现代 Java 推荐使用更先进的垃圾回收技术。

```

* 什么是序列化？什么是反序列化？

```
序列化和反序列化是用于将对象在内存中的状态转化为可存储或传输的格式的过程，以及将这些存储或传输的数据重新转化为对象的过程。
这些概念通常用于编程中，特别是在Java等编程语言中。

序列化（Serialization）：
> 序列化是将对象的状态转化为字节流或其他格式，以便将其保存到文件、数据库，或通过网络传输。<br>
> 序列化将对象的字段值转化为一系列字节，以便在不同的环境中进行存储和传输。这通常包括对象的属性、字段值和方法等。<br>
> 在Java中，你可以使用 Serializable 接口来标记一个类，以指示该类可以被序列化。然后，你可以使用对象输出流将对象序列化为字节流。<br>

反序列化（Deserialization）：
> 反序列化是将之前序列化的字节流或数据转化为对象的过程。
> 它用于从文件、数据库或通过网络传输的数据中重建对象的状态。
> 在Java中，你可以使用对象输入流来反序列化字节流，并将其转化为对象。

序列化和反序列化在许多方面都非常有用，包括：
> 在分布式系统中，在不同计算机之间传输对象。
> 将对象保存到磁盘以进行持久化，以便在程序重新启动时恢复对象状态。
> 在缓存中存储对象以提高性能。
> 在跨平台或不同编程语言之间共享数据。

需要注意的是，序列化可能会引入一些安全和兼容性问题，因此在设计和使用时需要小心处理。不是所有对象都可以或应该序列化，例如，敏感信息可能需要加密或其他保护措施。
```

* 什么是不可变类
```
不可变类（Immutable Class）是指在创建对象后，其状态（即对象的属性或字段）不能被修改或改变。一旦不可变类的对象被创建，它的状态就被固定，无法再被修改。这意味着不可变类的对象是只读的，不会发生内部状态的变化。

以下是不可变类的主要特征和优点：
1. 属性不可变：不可变类的属性（字段）在对象创建后不能被修改。如果需要更改对象的状态，必须创建一个全新的对象。
2. 线程安全：由于对象的状态不会改变，多个线程可以同时访问不可变对象而无需担心竞争条件，因此不可变类天生是线程安全的。
3. 缓存友好：由于不可变对象的状态不会变化，它们可以被安全地用作缓存键，因为缓存的键在查询期间不会发生变化。
4. 简化设计：不可变类的设计相对简单，因为不需要担心对象的状态变化，也不需要复杂的同步机制。
5. 可重用性：不可变类可以在多个地方重用，因为它们的状态不会变化，不会影响其他部分的代码。

典型的不可变类包括字符串（String）、数值类型（如Integer、Double）、枚举类型（enum）以及许多Java标准库中的类。

创建不可变类的关键是确保对象的属性在构造时被初始化，并且在构造后不能被修改。通常，不可变类的属性应该是private和final的，不提供修改属性值的方法，也不暴露可变对象的引用。

注意：不可变类的不变性是建立在其属性也是不可变的前提下的。如果不可变类包含可变对象的引用，那么它仍然可能受到可变对象的影响。因此，需要谨慎处理可变对象的引用。

```
* 为什么 Java 中 String 是不可变类？
```

> String 类中包含 char 数组 value、整形的 offset 和 count 三个属性，这三个属性都是 private 的，且没有提供方法修改数值，因此在初始化后无法从外部改变。
> String 类中的这三个属性都是被 final 修饰的，无法从内部进行改变；
> 方法区有一块特殊存储区域 String Pool，当创建 String 时，如果在 String Pool 中找到相同的字符串值，则会返回一个已存在 String 的引用而不会新建一个对象。假设 String 是可变的，则会导致其他引用这个字符串值的 String 的值发生变化。

字符串不可变性的本质在于 String 类的设计，它的内部结构确保了字符串在创建后不能被修改。这种设计确保了数据的安全性、线程安全性和 API 稳定性，以及在字符串池中的性能优化。
私有属性、final 修饰符以及字符串池的特性都是构成字符串不可变性的关键因素。这些因素使得字符串一旦创建就不能被修改，从而确保了在各种应用和多线程环境中的可靠性和性能。

```
>* 安全性：不可变字符串在多线程环境下更安全。由于字符串不可变，多个线程可以同时访问一个字符串对象而不必担心数据被修改。<br>
>* 性能：字符串常量池的存在使得字符串可以被缓存和重用，这有助于提高性能。因为字符串是不可变的，缓存的字符串不会在其他地方被修改。<br>
>* Hash 算法：字符串的不可变性确保了它的哈希码（HashCode）是稳定的。这对于将字符串用作键来构建哈希表非常重要。如果字符串是可变的，其哈希码可能会在内容变化时改变，导致在哈希表中找不到键。<br>
>* API 设计：Java 设计者之一认为不可变字符串更易于设计和使用。例如，String 类提供了大量的方法来处理字符串，这些方法返回新的字符串而不修改原始字符串。这种设计使 API 更容易理解和使用。<br>


* API 和 SPI 的区别
```
API（Application Programming Interface）和 SPI（Service Provider Interface）是两种不同的概念，用于不同的软件开发和集成场景。它们的主要区别如下：

API（Application Programming Interface）：
用途：API 是一组定义了软件组件、库或服务的接口，用于与其他软件组件进行通信和互操作。它定义了如何与组件进行交互，包括可用的函数、类、方法和参数。
访问性：API 是为开发者提供的，用于编程目的。它通常由组件或服务的提供者定义，并用于告诉开发者如何正确使用这些组件或服务。
稳定性：API 的稳定性较高，一旦发布，通常会遵循向后兼容性，以确保不破坏现有的应用程序。
示例：Java的标准库中的所有类和方法都具有API。开发人员可以使用这些API来编写Java应用程序，例如Java的集合框架、I/O操作等。

SPI（Service Provider Interface）：
用途：SPI 是一种设计模式，用于实现软件的可插拔性和扩展性。它通常用于创建可扩展的软件框架，允许第三方开发者提供插件或扩展。
访问性：SPI 是为框架或库的开发者提供的，而不是最终应用程序的开发者。它定义了接口和一种机制，通过该机制，开发者可以注册和加载特定接口的实现。
稳定性：SPI 接口是通常稳定的，但其实现可以是可插拔的。SPI 允许在运行时加载不同的实现，以扩展或替代现有功能。
示例：Java中的Java Database Connectivity（JDBC）是SPI的一个示例。JDBC定义了数据库访问的标准接口，而具体数据库厂商则提供了各自的JDBC驱动程序来实现这一接口。

总之，API用于定义和公开软件组件的接口供开发者使用，而SPI用于实现可插拔和可扩展的框架或库，允许第三方提供者注册和提供接口的实现。API通常是为应用程序的开发者提供的，而SPI通常是为框架或库的开发者提供的。
```